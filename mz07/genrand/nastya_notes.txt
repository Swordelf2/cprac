во-первых
переменные заводим выражением
NAME=value, где NAME - имя будущей переменной (все переменные принято называть заглавными буквами), value - строка-значение переменной
использование переменной осуществляется конструкцией $(NAME), тогда вместо указанного выражения "подставляется" value переменной
приянто задать такие переменные (значения необязательно ровно такие)
CC=gcc #компилятор
CFLAGS=-std=gnu11 -Wall -Wextra -c #флаги компилятора
LD=gcc #линкер
LFLAGS= #флаги линкера (здесь пустая строка)
OBJS=main.o rand.o #список всех объектных файлов, необходимых для сборки финального бинарника
TARGET=genrand #название результирующего бинарника

Далее, мейк работает по следующей схеме
мейкфайл содержит набор правил, описанных в следующем виде

rule: prerequisites
	commands-to-execute

Обрати внмание, что перед command-to-execute - один таб (\t)
где rule - либо произвольное имя, либо имя файла
prerequisites - строка имен файлов, необходимых для дальнейшего исполнения данного правила
commands-to-execute - набор строк, отеделенных начальным табом, которые будут исполнены. Заметим, что внутри можно использовать специальные переменные:
$@ == rule
$^ == prerequisites
$< == <первый элемент в prerequisites>
(например, если правило такое
nastya: loshara1 loshara2 loshara3
то $< будет равен loshara1 

мейк запускается командой make rule
Если rule - пустая строка, то make будет выполнять самое первое правило
Иначе, мейк пытается выполнить правило rule
Выполняет правила мейк следующим образом
Сначала он рекурсивно выполняет эту операция над каждым именем из prerequisites
При этом, если файла с таким именем нет, и правила для него нет, make фейлит.
Он смотрит, существует ли уже файл rule
Если нет, то он исполняет commands-to-execute 
Если да, то он смотрит дату его последнего изменения, а так же даты изменений всех prerequisites, и если cуществует более новый prerequisite, то мейк как бы "обновляет" файл rule, выполняя commands-to-execute
Это используется для того, чтобы не пересобирать проект после каждого изменения отдельно взятого модуля.

Рассмотрим пример
пусть есть три модуля
module1, module2, module 3, каждый со своими хедерами и сорсами (.h и .c)
и наш проект называется dobro
тогда, замутим такой мейкфайл

CC=gcc
LD=gcc
CFLAGS=-c -Wall -Wextra -std=gnu11 -O2 #флаг -c нужен, чтобы компилятор не линковал объектные файлы (то есть давал на выходе .)
LFLAGS=
OBJS=module1.o module2.o module3.o
TARGET=dobro

$(TARGET): $(OBJ)
    $(LD) $(LFLAGS) $^ -o $@

module1.o: module1.c
	$(CC) $(CFLAGS) $< -o $@

module2.o: module2.c
	$(CC) $(CFLAGS) $< -o $@

module3.o: module3.c
	$(CC) $(CFLAGS) $< -o $@


clean:
    rm -rf $(OBJ) $(TARGET) #очистить рабочую директорию от мусора

Однако, заметь, что объектные файлы также должны зависеть от соответствующих хедеров!
А также
Нам что писать новую строчку так для каждого модуля?

Я короче вкратце расскажу о решениях этих проблем
так называемые patter rule'ы имею вид
%.o: %.c , тогда любое имя вида name.o, если не нашло себе другого правила, придет сюда, и prerequisite будет name.c
Таким образом, все те правила создания объектных файлов заменить на строку
%.o: %.c
    $(CC) $(CFLAGS) $< -o $@

Оставшуюся последнюю проблему можно решить просто дополнительно записывая все зависимости от хедеров (к сожалению, хорошие автоматизированные решения либо сложные, либо требуют стороннее ПО, но для небольших проектов, этого хватает) в виде:
module1.o: module1.h
module2.o: module2.h
module3.o: module3.h


// Самые используемые названия правил
all: - используется как дефолтная, ставится самой первой, чтобы исполнялась именно она, когда в мейк явно не указывается правило)
clean: - очистка директории
install: установка программы

Все те правила, которые по задумке не должны соответствовать никакому файлу (такие, как вышеперечисленные), должны быть отдельно занесены в специальный список
в самом начале
.PHONY: all, clean
что объявляет правила all и clean такими, что make вообще не смотрит, есть ли файлы с такими названиями в директории
(если этого не сделать, начнутся пробелмы, если вдруг файлы с такими нвзваниями окажутся в рабочей директории)
